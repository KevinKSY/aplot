# Copyright 2014 Heliosphere Research LLC
# All rights reserved.

"""
    Unit test evaluation and summary script.
    
    This script is intended to be run after the LabVIEW-based test suite
    has finished.  It reads the log file generated by the test suite, prints
    any errors to the terminal, and compares the output images to reference
    renderings to catch regressions.
    
    Take two command-line arguments: the LabVIEW test suite output directory,
    and the directory with reference images.
         
    $ python script.py test_dir ref_dir
    
    Process exit code is 0 if all tests succeeded, 1 otherwise.
"""

import sys
import os.path as op
from matplotlib import _png
import numpy as np
import glob
import re

TOLERANCES = {}


class TestCase(object):

    def __init__(self, test_dir, ref_dir, line):
    
        match = re.match(r"(?P<vi>\w+)\s*(?P<status>\w+)\s*(?P<error>.*)?", line)
        
        self.viname = match.group('vi').replace('.vi','')
        self.status = match.group('status')
        
        self._pass = False
        self.rms = 0
        
        if self.status in ('OK',):
            test_image = op.join(test_dir, self.viname+'.png')
            ref_image = op.join(ref_dir, self.viname+'.png')
            if not op.isfile(test_image) and op.isfile(ref_image):
                self.status = "TEST IMAGE NOT PRESENT"
            elif op.isfile(test_image) and not op.isfile(ref_image):
                self.status = "REF IMAGE NOT PRESENT"
            elif op.isfile(test_image) and op.isfile(ref_image):
                self.rms = compare_pngs(test_image, ref_image)
                tol = TOLERANCES.get(self.viname, 0.5)
                if self.rms > tol or not np.isfinite(self.rms):
                    self.status = "RMS FAIL"
                else:
                    self._pass = True
            else:
                self._pass = True  # No test image and no ref image simply means this test doesn't produce an image
                
    def __nonzero__(self):
        return self._pass
        
def load_tolerances(fname):
    """ Load a dictionary with custom RMS limits.
    
    Dict keys are file (base)names, values are RMS limits to compare.
    """
    
    regexp = r'(?P<name>\w+\.png)\s+(?P<tol>[0-9\.]+)'
    
    dct = {}
    
    with open(fname, 'r') as f:
    
        for line in f:
            match = re.match(regexp, line)
            if match is None:
                continue
            dct[match.group('name')] = float(match.group('tol'))
            
    return dct
    

    

# Ported from Matplotlib
def compare_pngs(actual, expected):
    """ Compare two images using RMS approach.
    
    Actual and expected are paths to PNG files.
    
    Returns True for mismatch, False otherwise.
    """

    # open the image files and remove the alpha channel (if it exists)
    expectedImage = _png.read_png_int(expected)
    actualImage = _png.read_png_int(actual)
    expectedImage = expectedImage[:, :, :3]
    actualImage = actualImage[:, :, :3]

    # convert to signed integers, so that the images can be subtracted without
    # overflow
    expectedImage = expectedImage.astype(np.int16)
    actualImage = actualImage.astype(np.int16)

    num_values = np.prod(expectedImage.shape)
    abs_diff_image = abs(expectedImage - actualImage)

    histogram = np.bincount(abs_diff_image.ravel(), minlength=256)

    sum_of_squares = np.sum(histogram * np.arange(len(histogram)) ** 2)
    rms = np.sqrt(float(sum_of_squares) / num_values)
    
    return rms



def main():
    """ Calling sequence:
    
    python script.py test_dir ref_dir
    """
    test_dir, ref_dir = sys.argv[1:3]
    
    with open(op.join(test_dir, "TestLog.txt")) as f:
        tests = [TestCase(test_dir, ref_dir, line) for line in f if line.strip()]

    ntests = len(tests)
    nfail = len([x for x in tests if not x])
    nskipped = len([x for x in tests if x.status == "SKIPPED"])
    nexpfail = len([x for x in tests if x.status == "EXPFAIL"])
    nunexp = len([x for x in tests if x.status == 'UNEXPSUCCESS'])
    
    print '-'*79
    print "Ran %d tests (%d failed, %d skipped, %d/%d exp fail)" % (ntests, (nfail-nskipped-nexpfail-nunexp), nskipped, nexpfail, nunexp)
    print '-'*79
    
    failed = [x for x in tests if not x]
    if len(failed) > 0:
        for x in failed:
            print "%s: %s %s" % (x.viname, x.status, x.rms if x.status == "RMS FAIL" else "")
        print '-'*79

    return nfail == 0
    

if __name__ == "__main__":
    code = 0 if main() else 1
    sys.exit(code)